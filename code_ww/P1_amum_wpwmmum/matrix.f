      SUBROUTINE ME_ACCESSOR_HOOK(P,HEL,USER_ALPHAS,ANS)
      IMPLICIT NONE
C     
C     CONSTANT
C     
      INTEGER    NEXTERNAL
      PARAMETER (NEXTERNAL=5)
      INTEGER NSQAMPSO
      PARAMETER (NSQAMPSO=5)
      REAL*8 PI
      PARAMETER (PI= 3.141592653589793D0)
C     
C     ARGUMENTS 
C     
      REAL*8 P(0:3,NEXTERNAL),ANS(0:NSQAMPSO)
      INTEGER HEL
      DOUBLE PRECISION USER_ALPHAS
CF2PY INTENT(IN)  :: P
CF2PY INTENT(IN)  :: HEL
CF2PY INTENT(IN)  :: USER_ALPHAS
CF2PY INTENT(OUT) :: ANS

      REAL*8 THIS_G

      INCLUDE 'coupl.inc'

      INTEGER DEN
      COMMON/IDEN/DEN

      INTEGER FL_FACTOR
      COMMON/FLAVOUR_FACTOR/FL_FACTOR
      FL_FACTOR = 1

C     ----------
C     BEGIN CODE
C     ----------

      IF (USER_ALPHAS.GT.0.0D0) THEN
        THIS_G = 2* DSQRT(USER_ALPHAS*PI)
        IF (THIS_G.NE.G) THEN
          G = THIS_G
          CALL UPDATE_AS_PARAM()
        ENDIF
      ENDIF

      CALL SMATRIXHEL_SPLITORDERS(P,HEL,ANS)

      END

      SUBROUTINE SMATRIX(P,ANS_SUMMED)
C     
C     Simple routine wrapper to provide the same interface for
C     backward compatibility for usage without split orders.
C     
C     
C     CONSTANTS
C     
      INTEGER    NEXTERNAL
      PARAMETER (NEXTERNAL=5)
      INTEGER NSQAMPSO
      PARAMETER (NSQAMPSO=5)
C     
C     ARGUMENTS 
C     
      REAL*8 P(0:3,NEXTERNAL), ANS_SUMMED
C     
C     VARIABLES
C     
      INTEGER I
      REAL*8 ANS(0:NSQAMPSO)

C     
C     BEGIN CODE
C     

      CALL SMATRIX_SPLITORDERS(P,ANS)
      ANS_SUMMED=ANS(0)

      END

      SUBROUTINE SMATRIXHEL(P,HEL,ANS)
      IMPLICIT NONE
C     
C     CONSTANT
C     
      INTEGER    NEXTERNAL
      PARAMETER (NEXTERNAL=5)
      INTEGER                 NCOMB
      PARAMETER (             NCOMB=72)
C     
C     ARGUMENTS 
C     
      REAL*8 P(0:3,NEXTERNAL),ANS
      INTEGER HEL
C     
C     GLOBAL VARIABLES
C     
      INTEGER USERHEL
      COMMON/HELUSERCHOICE/USERHEL
C     ----------
C     BEGIN CODE
C     ----------
      USERHEL=HEL
      CALL SMATRIX(P,ANS)
      USERHEL=-1

      END

C     Give access to the helicity definition to the f2py API.
      SUBROUTINE GET_HELICITY_DEFINITIONS(NHEL_OUT)
      IMPLICIT NONE

      INTEGER    NEXTERNAL
      PARAMETER (NEXTERNAL=5)
      INTEGER    NCOMB
      PARAMETER (NCOMB=72)
      INTEGER NHEL(NEXTERNAL,NCOMB)
      COMMON/BORN_HEL_CONFIGS/NHEL

      INTEGER NHEL_OUT(NCOMB,NEXTERNAL)
CF2PY INTENT(OUT) :: NHEL_OUT

      INTEGER I,J

      DO I=1,NEXTERNAL
        DO J=1,NCOMB
          NHEL_OUT(J,I) = NHEL(I,J)
        ENDDO
      ENDDO

      END

      SUBROUTINE SMATRIX_SPLITORDERS(P,ANS)
C     
C     Generated by MadGraph5_aMC@NLO v. 2.5.3, 2017-03-09
C     By the MadGraph5_aMC@NLO Development Team
C     Visit launchpad.net/madgraph5 and amcatnlo.web.cern.ch
C     
C     MadGraph StandAlone Version
C     
C     Returns amplitude squared summed/avg over colors
C     and helicities
C     for the point in phase space P(0:3,NEXTERNAL)
C     
C     Process: a mu- > w+ w- mu- QCD^2<=4 QED^2<=8 @1
C     
      IMPLICIT NONE
C     
C     CONSTANTS
C     
      INTEGER    NEXTERNAL
      PARAMETER (NEXTERNAL=5)
      INTEGER    NINITIAL
      PARAMETER (NINITIAL=2)
      INTEGER NPOLENTRIES
      PARAMETER (NPOLENTRIES=(NEXTERNAL+1)*6)
      INTEGER                 NCOMB
      PARAMETER (             NCOMB=72)
      INTEGER NSQAMPSO
      PARAMETER (NSQAMPSO=5)
      INTEGER HELAVGFACTOR
      PARAMETER (HELAVGFACTOR=4)
      LOGICAL CHOSEN_SO_CONFIGS(NSQAMPSO)
      DATA CHOSEN_SO_CONFIGS/.TRUE.,.TRUE.,.TRUE.,.TRUE.,.TRUE./
      COMMON/CHOSEN_BORN_SQSO/CHOSEN_SO_CONFIGS
C     
C     ARGUMENTS 
C     
      REAL*8 P(0:3,NEXTERNAL),ANS(0:NSQAMPSO)
C     
C     LOCAL VARIABLES 
C     
      LOGICAL DO_INCLUDE_HEL_CONTRIB
      INTEGER NTRY
      REAL*8 T(NSQAMPSO), BUFF
      INTEGER IHEL,IDEN, I, J
C     For a 1>N process, them BEAMTWO_HELAVGFACTOR would be set to 1.
      INTEGER BEAMS_HELAVGFACTOR(2)
      DATA (BEAMS_HELAVGFACTOR(I),I=1,2)/2,2/
      INTEGER JC(NEXTERNAL)
      LOGICAL GOODHEL(NCOMB)
      DATA NTRY/0/
      DATA GOODHEL/NCOMB*.FALSE./

      INTEGER HELICITIES(NEXTERNAL)

      INTEGER DEN
      COMMON/IDEN/DEN

      DOUBLE PRECISION AMP2(18)
      COMMON/TO_AMP2/AMP2
      DOUBLE PRECISION SUM_AMP2

      DATA IDEN/ 4/
C     
C     GLOBAL VARIABLES
C     
      INTEGER NHEL(NEXTERNAL,NCOMB)
      DATA (NHEL(I,   1),I=1,5) /-1, 1,-1, 1,-1/
      DATA (NHEL(I,   2),I=1,5) /-1, 1,-1, 1, 1/
      DATA (NHEL(I,   3),I=1,5) /-1, 1,-1, 0,-1/
      DATA (NHEL(I,   4),I=1,5) /-1, 1,-1, 0, 1/
      DATA (NHEL(I,   5),I=1,5) /-1, 1,-1,-1,-1/
      DATA (NHEL(I,   6),I=1,5) /-1, 1,-1,-1, 1/
      DATA (NHEL(I,   7),I=1,5) /-1, 1, 0, 1,-1/
      DATA (NHEL(I,   8),I=1,5) /-1, 1, 0, 1, 1/
      DATA (NHEL(I,   9),I=1,5) /-1, 1, 0, 0,-1/
      DATA (NHEL(I,  10),I=1,5) /-1, 1, 0, 0, 1/
      DATA (NHEL(I,  11),I=1,5) /-1, 1, 0,-1,-1/
      DATA (NHEL(I,  12),I=1,5) /-1, 1, 0,-1, 1/
      DATA (NHEL(I,  13),I=1,5) /-1, 1, 1, 1,-1/
      DATA (NHEL(I,  14),I=1,5) /-1, 1, 1, 1, 1/
      DATA (NHEL(I,  15),I=1,5) /-1, 1, 1, 0,-1/
      DATA (NHEL(I,  16),I=1,5) /-1, 1, 1, 0, 1/
      DATA (NHEL(I,  17),I=1,5) /-1, 1, 1,-1,-1/
      DATA (NHEL(I,  18),I=1,5) /-1, 1, 1,-1, 1/
      DATA (NHEL(I,  19),I=1,5) /-1,-1,-1, 1,-1/
      DATA (NHEL(I,  20),I=1,5) /-1,-1,-1, 1, 1/
      DATA (NHEL(I,  21),I=1,5) /-1,-1,-1, 0,-1/
      DATA (NHEL(I,  22),I=1,5) /-1,-1,-1, 0, 1/
      DATA (NHEL(I,  23),I=1,5) /-1,-1,-1,-1,-1/
      DATA (NHEL(I,  24),I=1,5) /-1,-1,-1,-1, 1/
      DATA (NHEL(I,  25),I=1,5) /-1,-1, 0, 1,-1/
      DATA (NHEL(I,  26),I=1,5) /-1,-1, 0, 1, 1/
      DATA (NHEL(I,  27),I=1,5) /-1,-1, 0, 0,-1/
      DATA (NHEL(I,  28),I=1,5) /-1,-1, 0, 0, 1/
      DATA (NHEL(I,  29),I=1,5) /-1,-1, 0,-1,-1/
      DATA (NHEL(I,  30),I=1,5) /-1,-1, 0,-1, 1/
      DATA (NHEL(I,  31),I=1,5) /-1,-1, 1, 1,-1/
      DATA (NHEL(I,  32),I=1,5) /-1,-1, 1, 1, 1/
      DATA (NHEL(I,  33),I=1,5) /-1,-1, 1, 0,-1/
      DATA (NHEL(I,  34),I=1,5) /-1,-1, 1, 0, 1/
      DATA (NHEL(I,  35),I=1,5) /-1,-1, 1,-1,-1/
      DATA (NHEL(I,  36),I=1,5) /-1,-1, 1,-1, 1/
      DATA (NHEL(I,  37),I=1,5) / 1, 1,-1, 1,-1/
      DATA (NHEL(I,  38),I=1,5) / 1, 1,-1, 1, 1/
      DATA (NHEL(I,  39),I=1,5) / 1, 1,-1, 0,-1/
      DATA (NHEL(I,  40),I=1,5) / 1, 1,-1, 0, 1/
      DATA (NHEL(I,  41),I=1,5) / 1, 1,-1,-1,-1/
      DATA (NHEL(I,  42),I=1,5) / 1, 1,-1,-1, 1/
      DATA (NHEL(I,  43),I=1,5) / 1, 1, 0, 1,-1/
      DATA (NHEL(I,  44),I=1,5) / 1, 1, 0, 1, 1/
      DATA (NHEL(I,  45),I=1,5) / 1, 1, 0, 0,-1/
      DATA (NHEL(I,  46),I=1,5) / 1, 1, 0, 0, 1/
      DATA (NHEL(I,  47),I=1,5) / 1, 1, 0,-1,-1/
      DATA (NHEL(I,  48),I=1,5) / 1, 1, 0,-1, 1/
      DATA (NHEL(I,  49),I=1,5) / 1, 1, 1, 1,-1/
      DATA (NHEL(I,  50),I=1,5) / 1, 1, 1, 1, 1/
      DATA (NHEL(I,  51),I=1,5) / 1, 1, 1, 0,-1/
      DATA (NHEL(I,  52),I=1,5) / 1, 1, 1, 0, 1/
      DATA (NHEL(I,  53),I=1,5) / 1, 1, 1,-1,-1/
      DATA (NHEL(I,  54),I=1,5) / 1, 1, 1,-1, 1/
      DATA (NHEL(I,  55),I=1,5) / 1,-1,-1, 1,-1/
      DATA (NHEL(I,  56),I=1,5) / 1,-1,-1, 1, 1/
      DATA (NHEL(I,  57),I=1,5) / 1,-1,-1, 0,-1/
      DATA (NHEL(I,  58),I=1,5) / 1,-1,-1, 0, 1/
      DATA (NHEL(I,  59),I=1,5) / 1,-1,-1,-1,-1/
      DATA (NHEL(I,  60),I=1,5) / 1,-1,-1,-1, 1/
      DATA (NHEL(I,  61),I=1,5) / 1,-1, 0, 1,-1/
      DATA (NHEL(I,  62),I=1,5) / 1,-1, 0, 1, 1/
      DATA (NHEL(I,  63),I=1,5) / 1,-1, 0, 0,-1/
      DATA (NHEL(I,  64),I=1,5) / 1,-1, 0, 0, 1/
      DATA (NHEL(I,  65),I=1,5) / 1,-1, 0,-1,-1/
      DATA (NHEL(I,  66),I=1,5) / 1,-1, 0,-1, 1/
      DATA (NHEL(I,  67),I=1,5) / 1,-1, 1, 1,-1/
      DATA (NHEL(I,  68),I=1,5) / 1,-1, 1, 1, 1/
      DATA (NHEL(I,  69),I=1,5) / 1,-1, 1, 0,-1/
      DATA (NHEL(I,  70),I=1,5) / 1,-1, 1, 0, 1/
      DATA (NHEL(I,  71),I=1,5) / 1,-1, 1,-1,-1/
      DATA (NHEL(I,  72),I=1,5) / 1,-1, 1,-1, 1/
      COMMON/BORN_HEL_CONFIGS/NHEL

      INTEGER USERHEL
      DATA USERHEL/-1/
      COMMON/HELUSERCHOICE/USERHEL

      INTEGER POLARIZATIONS(0:NEXTERNAL,0:5)
      DATA ((POLARIZATIONS(I,J),I=0,NEXTERNAL),J=0,5)/NPOLENTRIES*-1/
      COMMON/BORN_BEAM_POL/POLARIZATIONS

C     
C     COLOR CORRELATORS DATA
C     
C     CCI will be the general color correlated index in loops
C     and CCIA is the index of the loop over COLOR_CORRELATORS_TO_CONSI
C     DER
      INTEGER CCI, CCIA

      INTEGER NCOLORCORRELATORS
      PARAMETER (NCOLORCORRELATORS=0)
      INTEGER NCC_TIMES_NSQAMPSO
      PARAMETER (NCC_TIMES_NSQAMPSO=NCOLORCORRELATORS*(NSQAMPSO+1))

C     Index 0 is the number of correlators to consider and the next
C      indices are which one to consider
      INTEGER COLOR_CORRELATORS_TO_CONSIDER(0:NCOLORCORRELATORS)
      DATA COLOR_CORRELATORS_TO_CONSIDER(0)/NCOLORCORRELATORS/


      REAL*8 COLOR_CORRELATED_EVALS(NCOLORCORRELATORS,0:NSQAMPSO)
      DATA ((COLOR_CORRELATED_EVALS(I,J), I=1,NCOLORCORRELATORS),J=0
     $ ,NSQAMPSO) / NCC_TIMES_NSQAMPSO*0.0D0 /
      COMMON/COLOR_CORRELATIONS/COLOR_CORRELATORS_TO_CONSIDER,
     $  COLOR_CORRELATED_EVALS

      INCLUDE 'spin_correlations.inc'
      INTEGER SPINCORR_HEL_INDICES(NEXTERNAL)
      LOGICAL SKIP_THIS_HELICITY
      INTEGER ISC
      COMPLEX*16 WEXT(20,NEXTERNAL)

C     
C     FUNCTIONS
C     
      LOGICAL IS_BORN_HEL_SELECTED

C     ----------
C     BEGIN CODE
C     ----------

      DEN = IDEN



C     
C     Reinitialize color correlated values
C     
      DO CCIA=1,COLOR_CORRELATORS_TO_CONSIDER(0)
        CCI = COLOR_CORRELATORS_TO_CONSIDER(CCIA)
        DO J=1,NSQAMPSO
          COLOR_CORRELATED_EVALS(CCI,J) = 0.0D0
        ENDDO
      ENDDO

      NTRY=NTRY+1
      DO IHEL=1,NEXTERNAL
        JC(IHEL) = +1
      ENDDO
      DO I=1,NSQAMPSO
        ANS(I) = 0D0
      ENDDO
C     When spin-2 particles are involved, the Helicity filtering is
C      dangerous for the 2->1 topology.
C     This is because depending on the MC setup the initial PS points
C      have back-to-back initial states
C     for which some of the spin-2 helicity configurations are zero.
C      But they are no longer zero
C     if the point is boosted on the z-axis. Remember that HELAS
C      helicity amplitudes are no longer
C     lorentz invariant with expternal spin-2 particles (only the
C      helicity sum is).
C     For this reason, we simply remove the filterin when there is
C      only three external particles.
      IF (NEXTERNAL.LE.3) THEN
        DO IHEL=1,NCOMB
          GOODHEL(IHEL)=.TRUE.
        ENDDO
      ENDIF

C     If spin correlations are active, then remove the helicity
C      filtering.
      IF (N_SPIN_CORR_RUNS.GT.0) THEN
        DO IHEL=1,NCOMB
          GOODHEL(IHEL)=.TRUE.
        ENDDO
        NTRY = 0
      ENDIF

C     Save helicity indices of the spin-correlated legs that we will
C      use to insert the extra spin. corr. runs.
      DO I=1,NEXTERNAL
        SPINCORR_HEL_INDICES(I) = -1000
      ENDDO

      DO IHEL=1,NCOMB
        IF (USERHEL.EQ.-1.OR.USERHEL.EQ.IHEL) THEN
          IF (GOODHEL(IHEL) .OR. NTRY .LT. 2 .OR.USERHEL.NE.-1) THEN
            IF(NTRY.GE.2.AND.POLARIZATIONS(0,0).NE.-1.AND.
     $       (.NOT.IS_BORN_HEL_SELECTED(IHEL))) THEN
              CYCLE
            ENDIF

            IF (N_SPIN_CORR_RUNS.GT.0) THEN
C             Now we know that we are in an helicity configuration
C              that was selected by the user
C             Record the helicity index of legs that are
C              spin-correlated
              DO I=1,NEXTERNAL
                IF (N_SPIN_CORR_VECTORS(I).GT.0.AND.SPINCORR_HEL_INDICE
     $S(I).EQ.-1000) THEN
                  SPINCORR_HEL_INDICES(I) = NHEL(I,IHEL)
                ENDIF
              ENDDO

C             Now make sure to skip all helicity configurations with
C              helicity indices for the spin-correlated legs that
C             does not match the first one encountered
              SKIP_THIS_HELICITY = .FALSE.
              DO I=1,NEXTERNAL
                IF (SPINCORR_HEL_INDICES(I).NE.-1000.AND.SPINCORR_HEL_I
     $NDICES(I).NE.NHEL(I,IHEL)) THEN
                  SKIP_THIS_HELICITY = .TRUE.
                  EXIT
                ENDIF
              ENDDO
              IF (SKIP_THIS_HELICITY) THEN
                CYCLE
              ENDIF
            ENDIF

C           Now insert the extra runs for the spin-correlations
C           The MIN statement allows to make sure that we proceed with
C            a normal run if not spin-correlations are active
            DO ISC=MIN(N_SPIN_CORR_RUNS,1),N_SPIN_CORR_RUNS
              DO_INCLUDE_HEL_CONTRIB = (POLARIZATIONS(0,0).EQ.
     $         -1.OR.IS_BORN_HEL_SELECTED(IHEL))
              DO I=1,NEXTERNAL
                IF (SPIN_CORR_RUNS(ISC, I).EQ.-1000) THEN
C                 No spin correlation, leave it as it is
                  HELICITIES(I) = NHEL(I,IHEL)
                  DO J=1,20
                    WEXT(J,I) = DCMPLX(0.0D0,0.0D0)
                  ENDDO
                ELSE
C                 Spin correlation, enforce the polarization vector
                  HELICITIES(I) = -1000
                  DO J=1,4
                    WEXT(J,I) = SPIN_CORR_VECTORS(I,SPIN_CORR_RUNS(ISC
     $               , I),J)
                  ENDDO
                  DO J=5,20
                    WEXT(J,I) = DCMPLX(0.0D0,0.0D0)
                  ENDDO
                ENDIF
              ENDDO
              CALL MATRIX(P ,HELICITIES(1),JC(1), T,
     $          DO_INCLUDE_HEL_CONTRIB, WEXT(1,1))
              BUFF=0D0
              DO I=1,NSQAMPSO
                IF(DO_INCLUDE_HEL_CONTRIB) THEN
                  ANS(I)=ANS(I)+T(I)
                ENDIF
                BUFF=BUFF+T(I)
              ENDDO
              IF (BUFF .NE. 0D0 .AND. .NOT.    GOODHEL(IHEL)) THEN
                GOODHEL(IHEL)=.TRUE.
              ENDIF
C             End of the do-loop for the insertion of the extra
C              spin-correlation runs
            ENDDO
          ENDIF
        ENDIF
      ENDDO
      ANS(0)=0.0D0
      DO CCIA=1,COLOR_CORRELATORS_TO_CONSIDER(0)
        CCI = COLOR_CORRELATORS_TO_CONSIDER(CCIA)
        COLOR_CORRELATED_EVALS(CCI,0) = 0.0D0
      ENDDO

      DO I=1,NSQAMPSO
        ANS(I)=ANS(I)/DBLE(IDEN)
        DO CCIA=1,COLOR_CORRELATORS_TO_CONSIDER(0)
          CCI = COLOR_CORRELATORS_TO_CONSIDER(CCIA)
          COLOR_CORRELATED_EVALS(CCI,I) = COLOR_CORRELATED_EVALS(CCI,I)
     $     /DBLE(IDEN)
        ENDDO
        IF (CHOSEN_SO_CONFIGS(I)) THEN
          ANS(0)=ANS(0)+ANS(I)
          DO CCIA=1,COLOR_CORRELATORS_TO_CONSIDER(0)
            CCI = COLOR_CORRELATORS_TO_CONSIDER(CCIA)
            COLOR_CORRELATED_EVALS(CCI,0) = COLOR_CORRELATED_EVALS(CCI
     $       ,0) + COLOR_CORRELATED_EVALS(CCI,I)
          ENDDO
        ENDIF
      ENDDO
      IF(USERHEL.NE.-1) THEN
        DO I=0,NSQAMPSO
          ANS(I)=ANS(I)*HELAVGFACTOR
          DO CCIA=1,COLOR_CORRELATORS_TO_CONSIDER(0)
            CCI = COLOR_CORRELATORS_TO_CONSIDER(CCIA)
            COLOR_CORRELATED_EVALS(CCI,I) = COLOR_CORRELATED_EVALS(CCI
     $       ,I)*HELAVGFACTOR
          ENDDO
        ENDDO
      ELSE
        DO J=1,NINITIAL
          IF (POLARIZATIONS(J,0).NE.-1) THEN
            DO I=0,NSQAMPSO
              ANS(I)=ANS(I)*BEAMS_HELAVGFACTOR(J)
              ANS(I)=ANS(I)/POLARIZATIONS(J,0)
              DO CCIA=1,COLOR_CORRELATORS_TO_CONSIDER(0)
                CCI = COLOR_CORRELATORS_TO_CONSIDER(CCIA)
                COLOR_CORRELATED_EVALS(CCI,I) = COLOR_CORRELATED_EVALS
     $           (CCI,I)*BEAMS_HELAVGFACTOR(J)
                COLOR_CORRELATED_EVALS(CCI,I) = COLOR_CORRELATED_EVALS
     $           (CCI,I)/POLARIZATIONS(J,0)
              ENDDO
            ENDDO
          ENDIF
        ENDDO
      ENDIF
      END

      SUBROUTINE SMATRIXHEL_SPLITORDERS(P,HEL,ANS)
      IMPLICIT NONE
C     
C     CONSTANT
C     
      INTEGER    NEXTERNAL
      PARAMETER (NEXTERNAL=5)
      INTEGER                 NCOMB
      PARAMETER (             NCOMB=72)
      INTEGER NSQAMPSO
      PARAMETER (NSQAMPSO=5)
C     
C     ARGUMENTS 
C     
      REAL*8 P(0:3,NEXTERNAL),ANS(0:NSQAMPSO)
      INTEGER HEL

CF2PY INTENT(IN)  :: P
CF2PY INTENT(IN)  :: HEL
CF2PY INTENT(OUT) :: ANS

C     
C     GLOBAL VARIABLES
C     
      INTEGER USERHEL
      COMMON/HELUSERCHOICE/USERHEL

      INTEGER DEN
      COMMON/IDEN/DEN
C     ----------
C     BEGIN CODE
C     ----------
      USERHEL=HEL
      CALL SMATRIX_SPLITORDERS(P,ANS)
      USERHEL=-1

      END

      SUBROUTINE MATRIX(P,NHEL,IC,RES, DO_INCLUDE_HEL_CONTRIB,WEXT)

C     
C     Generated by MadGraph5_aMC@NLO v. 2.5.3, 2017-03-09
C     By the MadGraph5_aMC@NLO Development Team
C     Visit launchpad.net/madgraph5 and amcatnlo.web.cern.ch
C     
C     Returns amplitude squared summed/avg over colors
C     for the point with external lines W(0:6,NEXTERNAL)
C     
C     Process: a mu- > w+ w- mu- QCD^2<=4 QED^2<=8 @1
C     
      IMPLICIT NONE
C     
C     CONSTANTS
C     
      INTEGER    NGRAPHS
      PARAMETER (NGRAPHS=18)
      INTEGER    NEXTERNAL
      PARAMETER (NEXTERNAL=5)
      INTEGER    NWAVEFUNCS, NCOLOR
      PARAMETER (NWAVEFUNCS=13, NCOLOR=1)
      INTEGER NAMPSO, NSQAMPSO
      PARAMETER (NAMPSO=3, NSQAMPSO=5)
      REAL*8     ZERO
      PARAMETER (ZERO=0D0)
      COMPLEX*16 IMAG1
      PARAMETER (IMAG1=(0D0,1D0))
C     
C     ARGUMENTS 
C     
      REAL*8 P(0:3,NEXTERNAL)
      INTEGER NHEL(NEXTERNAL), IC(NEXTERNAL)
      REAL*8 RES(NSQAMPSO)
      LOGICAL DO_INCLUDE_HEL_CONTRIB
      COMPLEX*16 WEXT(20,NEXTERNAL)
C     
C     LOCAL VARIABLES 
C     
      INTEGER I,J,M,N, SQSOIND
      COMPLEX*16 ZTEMP
      REAL*8 DENOM(NCOLOR), CF(NCOLOR,NCOLOR)
      COMPLEX*16 AMP(NGRAPHS)
      COMPLEX*16 JAMP(NCOLOR,NAMPSO)
      COMPLEX*16 W(20,NWAVEFUNCS)
      COMPLEX*16 DUM0,DUM1
      DATA DUM0, DUM1/(0D0, 0D0), (1D0, 0D0)/
      DOUBLE PRECISION AMP2(NGRAPHS),SUM_AMP2
      COMMON/TO_AMP2/AMP2
C     
C     FUNCTION
C     
      INTEGER SQSOINDEX
C     
C     GLOBAL VARIABLES
C     
      INCLUDE 'coupl.inc'
      INCLUDE 'spin_correlations.inc'
C     
C     COLOR DATA
C     
      DATA DENOM(1)/1/
      DATA (CF(I,  1),I=  1,  1) /    1/
C     1 ColorOne()

C     
C     COLOR CORRELATORS DATA
C     
C     CCI will be the general color correlated index in loops
C     and CCIA is the index of the loop over COLOR_CORRELATORS_TO_CONSI
C     DER
      INTEGER CCI, CCIA

      INTEGER NCOLORCORRELATORS
      PARAMETER (NCOLORCORRELATORS=0)

      COMPLEX*16 CCZTEMP(NCOLORCORRELATORS)

C     Index 0 is the number of correlators to consider and the next
C      indices are which one to consider
      INTEGER COLOR_CORRELATORS_TO_CONSIDER(0:NCOLORCORRELATORS)
      REAL*8 COLOR_CORRELATED_EVALS(NCOLORCORRELATORS, 0:NSQAMPSO)
      COMMON/COLOR_CORRELATIONS/COLOR_CORRELATORS_TO_CONSIDER,
     $  COLOR_CORRELATED_EVALS

      INTEGER CC_DENOM(NCOLORCORRELATORS,NCOLOR), CC_CF
     $ (NCOLORCORRELATORS,NCOLOR,NCOLOR)


C     ----------
C     BEGIN CODE
C     ----------

      IF (N_SPIN_CORR_RUNS.GT.0) THEN
C       First copy the external wavefunction with those provided
        DO I=1,NEXTERNAL
          DO J=1,20
            W(J,I) = WEXT(J,I)
          ENDDO
        ENDDO
      ENDIF

      CALL VXXXXX(P(0,1),ZERO,NHEL(1),-1*IC(1),W(1,1))
      CALL IXXXXX(P(0,2),ZERO,NHEL(2),+1*IC(2),W(1,2))
      CALL VXXXXX(P(0,3),MDL_MW,NHEL(3),+1*IC(3),W(1,3))
      CALL VXXXXX(P(0,4),MDL_MW,NHEL(4),+1*IC(4),W(1,4))
      CALL OXXXXX(P(0,5),ZERO,NHEL(5),+1*IC(5),W(1,5))
      CALL FFV1_2(W(1,2),W(1,1),GC_3,ZERO,ZERO,W(1,6))
      CALL VVV1P0_1(W(1,4),W(1,3),GC_4,ZERO,ZERO,W(1,7))
C     Amplitude(s) for diagram number 1
      CALL FFV1_0(W(1,6),W(1,5),W(1,7),GC_3,AMP(1))
      CALL VVV1P0_3(W(1,4),W(1,3),GC_71,MDL_MZ,MDL_WZ,W(1,8))
C     Amplitude(s) for diagram number 2
      CALL FFV2_4_0(W(1,6),W(1,5),W(1,8),GC_68,GC_77,AMP(2))
      CALL FFV2_1(W(1,5),W(1,3),GC_67,ZERO,ZERO,W(1,9))
C     Amplitude(s) for diagram number 3
      CALL FFV2_0(W(1,6),W(1,9),W(1,4),GC_67,AMP(3))
      CALL VVV1P0_2(W(1,1),W(1,3),GC_4,MDL_MW,MDL_WW,W(1,6))
      CALL FFV2_2(W(1,2),W(1,4),GC_67,ZERO,ZERO,W(1,10))
C     Amplitude(s) for diagram number 4
      CALL FFV2_0(W(1,10),W(1,5),W(1,6),GC_67,AMP(4))
      CALL FFV1P0_3(W(1,2),W(1,5),GC_3,ZERO,ZERO,W(1,11))
C     Amplitude(s) for diagram number 5
      CALL VVV1_0(W(1,11),W(1,4),W(1,6),GC_4,AMP(5))
      CALL FFV2_4P0_3(W(1,2),W(1,5),GC_68,GC_77,MDL_MZ,MDL_WZ,W(1,12))
C     Amplitude(s) for diagram number 6
      CALL VVV1_0(W(1,4),W(1,6),W(1,12),GC_71,AMP(6))
      CALL VVS1_3(W(1,1),W(1,3),GC_93,MDL_MW,MDL_WW,W(1,6))
C     Amplitude(s) for diagram number 7
      CALL VVS1_0(W(1,11),W(1,4),W(1,6),GC_92,AMP(7))
C     Amplitude(s) for diagram number 8
      CALL VVS1_0(W(1,4),W(1,12),W(1,6),GC_85,AMP(8))
      CALL VVV1P0_3(W(1,1),W(1,4),GC_4,MDL_MW,MDL_WW,W(1,6))
C     Amplitude(s) for diagram number 9
      CALL VVV1_0(W(1,11),W(1,6),W(1,3),GC_4,AMP(9))
C     Amplitude(s) for diagram number 10
      CALL VVV1_0(W(1,6),W(1,3),W(1,12),GC_71,AMP(10))
      CALL VVS1_3(W(1,1),W(1,4),GC_92,MDL_MW,MDL_WW,W(1,13))
C     Amplitude(s) for diagram number 11
      CALL VVS1_0(W(1,11),W(1,3),W(1,13),GC_93,AMP(11))
C     Amplitude(s) for diagram number 12
      CALL VVS1_0(W(1,3),W(1,12),W(1,13),GC_84,AMP(12))
C     Amplitude(s) for diagram number 13
      CALL FFV2_0(W(1,2),W(1,9),W(1,6),GC_67,AMP(13))
      CALL FFV1_1(W(1,5),W(1,1),GC_3,ZERO,ZERO,W(1,6))
C     Amplitude(s) for diagram number 14
      CALL FFV2_0(W(1,10),W(1,6),W(1,3),GC_67,AMP(14))
C     Amplitude(s) for diagram number 15
      CALL FFV1_0(W(1,2),W(1,6),W(1,7),GC_3,AMP(15))
C     Amplitude(s) for diagram number 16
      CALL FFV2_4_0(W(1,2),W(1,6),W(1,8),GC_68,GC_77,AMP(16))
      CALL VVVV2P0_1(W(1,1),W(1,4),W(1,3),GC_5,ZERO,ZERO,W(1,6))
C     Amplitude(s) for diagram number 17
      CALL FFV1_0(W(1,2),W(1,5),W(1,6),GC_3,AMP(17))
      CALL VVVV5P0_4(W(1,1),W(1,4),W(1,3),GC_75,MDL_MZ,MDL_WZ,W(1,6))
C     Amplitude(s) for diagram number 18
      CALL FFV2_4_0(W(1,2),W(1,5),W(1,6),GC_68,GC_77,AMP(18))
C     JAMPs contributing to orders QCD=2 QED=1
      JAMP(1,1)=+AMP(1)+AMP(15)
C     JAMPs contributing to orders QCD=1 QED=2
      JAMP(1,2)=+AMP(2)+AMP(3)+AMP(5)+AMP(7)+AMP(9)+AMP(11)+AMP(14)
     $ +AMP(16)+AMP(17)
C     JAMPs contributing to orders QCD=0 QED=3
      JAMP(1,3)=+AMP(4)+AMP(6)+AMP(8)+AMP(10)+AMP(12)+AMP(13)+AMP(18)


      AMP2=0D0
      SUM_AMP2=0D0
      DO I=1,NGRAPHS
        AMP2(I)=AMP2(I)+AMP(I)*DCONJG(AMP(I))
        SUM_AMP2 = SUM_AMP2 + AMP2(I)
      ENDDO
C     Normalization
      AMP2(:)=AMP2(:)/SUM_AMP2

      RES = 0.D0
      DO M = 1, NAMPSO
        DO I = 1, NCOLOR
          ZTEMP = (0.D0,0.D0)
          DO CCI=1,NCOLORCORRELATORS
            CCZTEMP(CCI) = (0.D0,0.D0)
          ENDDO
          DO J = 1, NCOLOR
            ZTEMP = ZTEMP + CF(J,I)*JAMP(J,M)
            IF (DO_INCLUDE_HEL_CONTRIB) THEN
              DO CCIA=1,COLOR_CORRELATORS_TO_CONSIDER(0)
                CCI = COLOR_CORRELATORS_TO_CONSIDER(CCIA)
                IF (CC_DENOM(CCI,1).NE.0) THEN
                  CCZTEMP(CCI) = CCZTEMP(CCI) + CC_CF(CCI,J,I)*JAMP(J
     $             ,M)
                ENDIF
              ENDDO
            ENDIF
          ENDDO
          DO N = 1, NAMPSO
            SQSOIND = SQSOINDEX(M,N)
            RES(SQSOIND) = RES(SQSOIND) + ZTEMP*DCONJG(JAMP(I,N))
     $       /DENOM(I)
            IF (DO_INCLUDE_HEL_CONTRIB) THEN
              DO CCIA=1,COLOR_CORRELATORS_TO_CONSIDER(0)
                CCI = COLOR_CORRELATORS_TO_CONSIDER(CCIA)
                IF (CC_DENOM(CCI,1).NE.0) THEN
                  COLOR_CORRELATED_EVALS(CCI,SQSOIND) =
     $              COLOR_CORRELATED_EVALS(CCI,SQSOIND) + CCZTEMP(CCI)
     $             *DCONJG(JAMP(I,N))/CC_DENOM(CCI,I)
                ENDIF
              ENDDO
            ENDIF
          ENDDO
        ENDDO
      ENDDO

      END

      SUBROUTINE GET_ME(P, ALPHAS, NHEL ,ANS)
      IMPLICIT NONE
C     
C     CONSTANT
C     
      INTEGER    NEXTERNAL
      PARAMETER (NEXTERNAL=5)
C     
C     ARGUMENTS 
C     
      REAL*8 P(0:3,NEXTERNAL),ANS
      INTEGER NHEL
      DOUBLE PRECISION ALPHAS
      REAL*8 PI
CF2PY INTENT(OUT) :: ANS
CF2PY INTENT(IN) :: NHEL
CF2PY INTENT(IN) :: P(0:3,NEXTERNAL)
CF2PY INTENT(IN) :: ALPHAS
C     ROUTINE FOR F2PY to read the benchmark point.    
C     the include file with the values of the parameters and masses 
      INCLUDE 'coupl.inc'

      PI = 3.141592653589793D0
      G = 2* DSQRT(ALPHAS*PI)
      CALL UPDATE_AS_PARAM()
      IF (NHEL.NE.0) THEN
        CALL SMATRIXHEL(P, NHEL, ANS)
      ELSE
        CALL SMATRIX(P, ANS)
      ENDIF
      RETURN
      END

      SUBROUTINE INITIALISE(PATH)
C     ROUTINE FOR F2PY to read the benchmark point.    
      IMPLICIT NONE
      CHARACTER*512 PATH
CF2PY INTENT(IN) :: PATH
C     USE SETPARA2 and not SETPARA so that ident_card.dat can be
C      automatically found
      CALL SETPARA2(PATH)  !first call to setup the paramaters    
      RETURN
      END

      LOGICAL FUNCTION IS_BORN_HEL_SELECTED(HELID)
      IMPLICIT NONE
C     
C     CONSTANTS
C     
      INTEGER    NEXTERNAL
      PARAMETER (NEXTERNAL=5)
      INTEGER    NCOMB
      PARAMETER (NCOMB=72)
C     
C     ARGUMENTS
C     
      INTEGER HELID
C     
C     LOCALS
C     
      INTEGER I,J
      LOGICAL FOUNDIT
C     
C     GLOBALS
C     
      INTEGER HELC(NEXTERNAL,NCOMB)
      COMMON/BORN_HEL_CONFIGS/HELC

      INTEGER POLARIZATIONS(0:NEXTERNAL,0:5)
      COMMON/BORN_BEAM_POL/POLARIZATIONS
C     ----------
C     BEGIN CODE
C     ----------

      IS_BORN_HEL_SELECTED = .TRUE.
      IF (POLARIZATIONS(0,0).EQ.-1) THEN
        RETURN
      ENDIF

      DO I=1,NEXTERNAL
        IF (POLARIZATIONS(I,0).EQ.-1) THEN
          CYCLE
        ENDIF
        FOUNDIT = .FALSE.
        DO J=1,POLARIZATIONS(I,0)
          IF (HELC(I,HELID).EQ.POLARIZATIONS(I,J)) THEN
            FOUNDIT = .TRUE.
            EXIT
          ENDIF
        ENDDO
        IF(.NOT.FOUNDIT) THEN
          IS_BORN_HEL_SELECTED = .FALSE.
          RETURN
        ENDIF
      ENDDO

      RETURN
      END


C     --------------------------------------------------------------
C     Beginning of a series of subroutine related to the evaluation
C     and steering of the computation of color-correlated MEs.
C     --------------------------------------------------------------

      SUBROUTINE GET_COLOR_CORRELATED_ME(CORRELATED_MES)
      IMPLICIT NONE
C     Provide access to the color correlated evaluations
      INTEGER CCI, I, J
      INTEGER    NEXTERNAL
      PARAMETER (NEXTERNAL=5)
      INTEGER NAMPSO, NSQAMPSO
      PARAMETER (NAMPSO=3, NSQAMPSO=5)
      INTEGER NCOLORCORRELATORS
      PARAMETER (NCOLORCORRELATORS=0)

      REAL*8 CORRELATED_MES(NCOLORCORRELATORS, 0:NSQAMPSO)
CF2PY INTENT(OUT) :: CORRELATED_MES

C     Index 0 is the number of correlators to consider and the next
C      indices are which one to consider
      INTEGER COLOR_CORRELATORS_TO_CONSIDER(0:NCOLORCORRELATORS)
      REAL*8 COLOR_CORRELATED_EVALS(NCOLORCORRELATORS, 0:NSQAMPSO)
      COMMON/COLOR_CORRELATIONS/COLOR_CORRELATORS_TO_CONSIDER,
     $  COLOR_CORRELATED_EVALS

      DO CCI=1,NCOLORCORRELATORS
        DO J=0,NSQAMPSO
          CORRELATED_MES(CCI, J) = COLOR_CORRELATED_EVALS(CCI, J)
        ENDDO
      ENDDO

      END

      SUBROUTINE GET_COLOR_CORRELATOR_ID(CONNECTION_INDEX_A,
     $  CONNECTION_INDEX_B, ID)
      IMPLICIT NONE

      INTEGER NCOLORCORRELATORS
      PARAMETER (NCOLORCORRELATORS=0)
      INTEGER NCOLORCONNECTIONS
      PARAMETER (NCOLORCONNECTIONS=0)

      INTEGER CONNECTION_INDEX_A, CONNECTION_INDEX_B, ID, IDX
CF2PY INTENT(IN) :: CONNECTION_INDEX_A
CF2PY INTENT(IN) :: CONNECTION_INDEX_B
CF2PY INTENT(OUT) :: ID

      INTEGER COLOR_CORRELATOR_TO_INDEX(NCOLORCONNECTIONS
     $ ,NCOLORCONNECTIONS)
      INTEGER CORRELATOR_INDEX_TO_CONNECTION_INDEX(NCOLORCORRELATORS,
     $  2)
      COMMON/COLOR_CORRELATION_MAPS/COLOR_CORRELATOR_TO_INDEX,
     $  CORRELATOR_INDEX_TO_CONNECTION_INDEX

      IDX = COLOR_CORRELATOR_TO_INDEX(CONNECTION_INDEX_A,
     $  CONNECTION_INDEX_B)

      IF (IDX.LE.0) THEN
        ID = -1
      ELSE
        ID = IDX
      ENDIF

      END

      SUBROUTINE GET_COLOR_CORRELATOR_FOR_ID(IDX, CONNECTION_INDEX_A,
     $  CONNECTION_INDEX_B)
      IMPLICIT NONE

      INTEGER NCOLORCORRELATORS
      PARAMETER (NCOLORCORRELATORS=0)
      INTEGER NCOLORCONNECTIONS
      PARAMETER (NCOLORCONNECTIONS=0)

      INTEGER CONNECTION_INDEX_A, CONNECTION_INDEX_B, IDX
CF2PY INTENT(IN) :: IDX
CF2PY INTENT(OUT) :: CONNECTION_INDEX_A
CF2PY INTENT(OUT) :: CONNECTION_INDEX_B

      INTEGER COLOR_CORRELATOR_TO_INDEX(NCOLORCONNECTIONS
     $ ,NCOLORCONNECTIONS)
      INTEGER CORRELATOR_INDEX_TO_CONNECTION_INDEX(NCOLORCORRELATORS,
     $  2)
      COMMON/COLOR_CORRELATION_MAPS/COLOR_CORRELATOR_TO_INDEX,
     $  CORRELATOR_INDEX_TO_CONNECTION_INDEX

      CONNECTION_INDEX_A = CORRELATOR_INDEX_TO_CONNECTION_INDEX(IDX, 1)
      CONNECTION_INDEX_B = CORRELATOR_INDEX_TO_CONNECTION_INDEX(IDX, 2)

      END

      SUBROUTINE GET_N_COLOR_CORRELATORS(N_COLOR_CORRELATORS)
C     Provide access to the number of color correlators

      INTEGER N_COLOR_CORRELATORS
CF2PY INTENT(OUT) :: N_COLOR_CORRELATORS

      INTEGER NCOLORCORRELATORS
      PARAMETER (NCOLORCORRELATORS=0)

      N_COLOR_CORRELATORS = NCOLORCORRELATORS

      END

      SUBROUTINE ADD_COLOR_CORRELATORS_TO_CONSIDER(FIRST_CONNECTION,
     $  SECOND_CONNECTION)
      IMPLICIT NONE
C     Adds a color correlator to compute. All leg indices must be
C      positive in this case.

      INTEGER NCOLORCORRELATORS
      PARAMETER (NCOLORCORRELATORS=0)
      INTEGER NCOLORCONNECTIONS
      PARAMETER (NCOLORCONNECTIONS=0)

      INTEGER FIRST_CONNECTION, SECOND_CONNECTION
CF2PY INTENT(IN) :: FIRST_CONNECTION
CF2PY INTENT(IN) :: SECOND_CONNECTION

      INTEGER COLOR_CORRELATOR_TO_INDEX(NCOLORCONNECTIONS
     $ ,NCOLORCONNECTIONS)
      INTEGER CORRELATOR_INDEX_TO_CONNECTION_INDEX(NCOLORCORRELATORS,
     $  2)
      COMMON/COLOR_CORRELATION_MAPS/COLOR_CORRELATOR_TO_INDEX,
     $  CORRELATOR_INDEX_TO_CONNECTION_INDEX

C     Index 0 is the number of correlators to consider and the next
C      indices are which one to consider
      INTEGER COLOR_CORRELATORS_TO_CONSIDER(0:NCOLORCORRELATORS)
      REAL*8 COLOR_CORRELATED_EVALS(NCOLORCORRELATORS)
      COMMON/COLOR_CORRELATIONS/COLOR_CORRELATORS_TO_CONSIDER,
     $  COLOR_CORRELATED_EVALS

C     ----------
C     BEGIN CODE
C     ----------

      IF (COLOR_CORRELATORS_TO_CONSIDER(0).GE.NCOLORCORRELATORS) THEN
        WRITE(*,*) 'Cannot add more color correlators to consider than'
     $   //' there are color correlators.'
        STOP
      ENDIF

      COLOR_CORRELATORS_TO_CONSIDER(0) = COLOR_CORRELATORS_TO_CONSIDER
     $ (0) +1
      COLOR_CORRELATORS_TO_CONSIDER(COLOR_CORRELATORS_TO_CONSIDER(0))
     $  = COLOR_CORRELATOR_TO_INDEX(FIRST_CONNECTION,
     $  SECOND_CONNECTION)

      END SUBROUTINE

      SUBROUTINE SET_COLOR_CORRELATORS_TO_CONSIDER(FIRST_CONNECTION,
     $  SECOND_CONNECTION)
      IMPLICIT NONE
C     Sets which color correlators to compute. If both connections are
C      specified, this will select only one.
C     For each leg index set to -1, we will span the entire set of
C      connections for that leg index.

      INTEGER FIRST_CONNECTION, SECOND_CONNECTION
CF2PY INTENT(IN) :: FIRST_CONNECTION
CF2PY INTENT(IN) :: SECOND_CONNECTION

      INTEGER NAMPSO, NSQAMPSO
      PARAMETER (NAMPSO=3, NSQAMPSO=5)
      INTEGER NCOLORCORRELATORS
      PARAMETER (NCOLORCORRELATORS=0)
      INTEGER NCOLORCONNECTIONS
      PARAMETER (NCOLORCONNECTIONS=0)

      INTEGER I, J, K, NCC_TO_CONSIDER, CC_TO_ADD
      LOGICAL FOUNDIT

      INTEGER COLOR_CORRELATOR_TO_INDEX(NCOLORCONNECTIONS
     $ ,NCOLORCONNECTIONS)


      INTEGER CORRELATOR_INDEX_TO_CONNECTION_INDEX(NCOLORCORRELATORS,
     $  2)


      COMMON/COLOR_CORRELATION_MAPS/COLOR_CORRELATOR_TO_INDEX,
     $  CORRELATOR_INDEX_TO_CONNECTION_INDEX

C     Index 0 is the number of correlators to consider and the next
C      indices are which one to consider
      INTEGER COLOR_CORRELATORS_TO_CONSIDER(0:NCOLORCORRELATORS)
      REAL*8 COLOR_CORRELATED_EVALS(NCOLORCORRELATORS, 0:NSQAMPSO)
      COMMON/COLOR_CORRELATIONS/COLOR_CORRELATORS_TO_CONSIDER,
     $  COLOR_CORRELATED_EVALS

      NCC_TO_CONSIDER = 0

C     First reset the array
      COLOR_CORRELATORS_TO_CONSIDER(0) = 0
      DO I=1,NCOLORCORRELATORS
        COLOR_CORRELATORS_TO_CONSIDER(I) = -1
      ENDDO

C     Index 0 on the first leg simply indicate the desire to reset the
C      selection
      IF (FIRST_CONNECTION.EQ.0) THEN
        RETURN
      ENDIF

      DO I=1, NCOLORCONNECTIONS
        IF (FIRST_CONNECTION.NE.-1.AND.FIRST_CONNECTION.NE.I) THEN
          CYCLE
        ENDIF
        DO J=1, NCOLORCONNECTIONS
          IF (SECOND_CONNECTION.NE.-1.AND.SECOND_CONNECTION.NE.J) THEN
            CYCLE
          ENDIF
C         Normally all those correlators should be found, even though
C          some might have not
C         have a contributing interference  
          CC_TO_ADD = COLOR_CORRELATOR_TO_INDEX(I,J)
          IF (CC_TO_ADD.LE.0) THEN
            CYCLE
          ENDIF
C         Now make sure we have not considered it yet, since (i, j)
C          maps to (j, i) in these correlators
          FOUNDIT = .FALSE.
          DO K=1,COLOR_CORRELATORS_TO_CONSIDER(0)
            IF (COLOR_CORRELATORS_TO_CONSIDER(K).EQ.CC_TO_ADD) THEN
              FOUNDIT = .TRUE.
              EXIT
            ENDIF
          ENDDO
          IF (FOUNDIT) THEN
            CYCLE
          ENDIF
          NCC_TO_CONSIDER = NCC_TO_CONSIDER+1
          COLOR_CORRELATORS_TO_CONSIDER(0) = NCC_TO_CONSIDER
          COLOR_CORRELATORS_TO_CONSIDER(NCC_TO_CONSIDER) = CC_TO_ADD
        ENDDO
      ENDDO

      END

C     gl  
      DOUBLE PRECISION FUNCTION GET_CCBLO(LEG_A,LEG_B)
      IMPLICIT NONE
C     given a color dipole pair, return the
C     corresponding COLOR_CORRELATED_EVALS value
      INTEGER I,J
      INTEGER LEG_A, LEG_B
      INTEGER NCOLORCORRELATORS
      PARAMETER (NCOLORCORRELATORS=0)
      INTEGER NSQAMPSO
      PARAMETER (NSQAMPSO=5)
      INTEGER COLOR_CORRELATORS_TO_CONSIDER(0:NCOLORCORRELATORS)
      REAL*8 COLOR_CORRELATED_EVALS(NCOLORCORRELATORS,0:NSQAMPSO)
C     DATA ((COLOR_CORRELATED_EVALS(I,J), I=1,NCOLORCORRELATORS),J=0,NS
C     QAMPSO)      
      COMMON/COLOR_CORRELATIONS/COLOR_CORRELATORS_TO_CONSIDER
     $ ,COLOR_CORRELATED_EVALS
      INTEGER COLOR_DIPOLES(2,NCOLORCORRELATORS)
      DATA COLOR_DIPOLES(:,:) //
      DO I=1,NCOLORCORRELATORS
        IF((LEG_A.EQ.COLOR_DIPOLES(1,I).AND.LEG_B.EQ.COLOR_DIPOLES(2,I)
     $   ))THEN
          GET_CCBLO = COLOR_CORRELATED_EVALS(I,1)
          EXIT
        ENDIF
      ENDDO
      RETURN
      END FUNCTION

C     --------------------------------------------------------------
C     Beginning of a series of subroutine related to the evaluation
C     and steering of the computation of spin-correlated MEs.
C     --------------------------------------------------------------

      DOUBLE PRECISION FUNCTION GET_KKBLO(PARENT_LEG,PB,KT)
      IMPLICIT NONE
      INTEGER I
      INTEGER NEXTERNAL
      PARAMETER (NEXTERNAL=5)
      INTEGER NSQAMPSO
      PARAMETER (NSQAMPSO=5)
      INTEGER PARENT_LEG
      DOUBLE PRECISION PB(0:3,NEXTERNAL)
      DOUBLE PRECISION KT(0:3)
      DOUBLE PRECISION MATELEMS(0:NSQAMPSO)

      INCLUDE 'spin_correlations.inc'
      INTEGER NENTRIES
      PARAMETER(NENTRIES=MAX_N_SPIN_CORR_VECTORS*4)
      REAL*8 SCVECTORS(MAX_N_SPIN_CORR_VECTORS,4)
      DATA SCVECTORS/NENTRIES*.0D0/
      INTEGER NVECTOR_TO_TRY_PER_LEG
      PARAMETER(NVECTOR_TO_TRY_PER_LEG=MIN(3,MAX_N_SPIN_CORR_VECTORS))

      CALL RESET_SPIN_CORRELATION_VECTORS()

      DO I=1,4
        SCVECTORS(1,I) = KT(I-1)
      ENDDO

      CALL SET_SPIN_CORRELATION_VECTORS(PARENT_LEG,NVECTOR_TO_TRY_PER_L
     $EG,SCVECTORS)
      CALL SMATRIX_SPLITORDERS(PB,MATELEMS)
      GET_KKBLO = MATELEMS(0)

      CALL RESET_SPIN_CORRELATION_VECTORS()

      RETURN
      END FUNCTION

      SUBROUTINE SET_SPIN_CORRELATION_VECTORS(LEG_INDEX, N_VECTORS,
     $  VECTORS)
      IMPLICIT NONE
C     Sets a list of up to MAX_N_VECTORS to use instead of the
C      polarization vectors for leg number LEG_INDEX
C     Notice that of course only fermions and vectors can be assigned
C      correlations here.

C     
C     CONSTANTS AND GLOBALS
C     

      INTEGER    NEXTERNAL
      PARAMETER (NEXTERNAL=5)
      INCLUDE 'spin_correlations.inc'

C     
C     ARGUMENTS
C     
      INTEGER LEG_INDEX
      INTEGER N_VECTORS
      REAL*8 VECTORS(MAX_N_SPIN_CORR_VECTORS,4)
CF2PY INTENT(IN) :: LEG_INDEX
CF2PY INTENT(IN) :: N_VECTORS
CF2PY INTENT(IN) :: VECTORS

C     
C     LOCAL VARIABLES
C     

      INTEGER I,J,N
      INTEGER NEW_N_SPIN_CORR_RUNS
      INTEGER N_LEGS_WITH_SPIN_CORRELATORS

C     
C     GLOBAL ARRAYS INITIALIZATION
C     

      INTEGER SPIN_CORR_VECTORS_N_ENTRIES
      PARAMETER (SPIN_CORR_VECTORS_N_ENTRIES=(4*NEXTERNAL*MAX_N_SPIN_CO
     $RR_VECTORS))
      DATA SPIN_CORR_VECTORS/SPIN_CORR_VECTORS_N_ENTRIES*0.0D0/
      DATA N_SPIN_CORR_VECTORS/NEXTERNAL*0/
      INTEGER SPIN_CORR_RUNS_N_ENTRIES
      PARAMETER (SPIN_CORR_RUNS_N_ENTRIES=(MAX_SPIN_CORR_RUNS+1)
     $ *NEXTERNAL)
C     The integer -1000 will indicate to simply keep the original
C      helicity polarization vector assigned to that leg      
      DATA SPIN_CORR_RUNS/SPIN_CORR_RUNS_N_ENTRIES*-1000/
      DATA N_SPIN_CORR_RUNS/0/

      INTEGER NEW_SPIN_CORR_RUNS(0:MAX_SPIN_CORR_RUNS,NEXTERNAL)

C     ----------
C     BEGIN CODE
C     ----------

C     Make sure the user does not try to set the spin-correlation
C      vectors of a leg again
      IF (N_SPIN_CORR_VECTORS(LEG_INDEX).NE.0) THEN
        WRITE(*,*) 'Cannot define for a second time the spin'
     $   //'-correlation vectors of a lef. Call the subroutine'
     $   //' RESET_SPIN_CORRELATION_VECTORS() first.'
        STOP
      ENDIF

C     Make sure it does not exceed the maximum number of legs that can
C      get spin correlators assigned.
      N_LEGS_WITH_SPIN_CORRELATORS = 0
      DO I=1,NEXTERNAL
        IF (N_SPIN_CORR_VECTORS(I).GT.0) THEN
          N_LEGS_WITH_SPIN_CORRELATORS = N_LEGS_WITH_SPIN_CORRELATORS 
     $     + 1
        ENDIF
      ENDDO
      IF (N_LEGS_WITH_SPIN_CORRELATORS.GE.MAX_LEGS_WITH_SPIN_CORR) THEN
        WRITE(*,*) 'In the current output, only a maximum of '
     $   ,MAX_LEGS_WITH_SPIN_CORR,' can be assigned spin-correlations.'
        WRITE(*,*) 'Change the parameter MAX_LEGS_WITH_SPIN_CORR in'
     $   //' spin_correlations.inc or re-generate the process with a'
     $   //' higher power of N for the option --spin_correlators=N^iLO'
        STOP
      ENDIF

C     First add the vectors to the list of spin-correlation vectors
C      defined
      N_SPIN_CORR_VECTORS(LEG_INDEX) = N_VECTORS
      DO I=1,N_VECTORS
        DO J=1,4
C         Leave the flexibility of having these vectors complex,
C          although we take them real here.
          SPIN_CORR_VECTORS(LEG_INDEX,I,J) = DCMPLX(VECTORS(I,J),0.0D0)
        ENDDO
      ENDDO

C     Now assign the additional runs to be performed within the loop
C      over helicity configuration so as to capture these
C      spin-correlations.
C     First initialise the new runs to empty
      DO I=0, MAX_SPIN_CORR_RUNS
        DO J=1,NEXTERNAL
          NEW_SPIN_CORR_RUNS(I,J) = -1000
        ENDDO
      ENDDO
      NEW_N_SPIN_CORR_RUNS = 0

C     Now recompute what are the spin-correlated runs to be performed
C      within the loop over helicity configuration so as to capture
C      these spin-correlations.
      DO I=1,N_VECTORS
C       Add a run for each of the existing ones. This means that if
C        user specifies vector VEC1A and VEC1B for leg 1, and VEC2A
C        and VEC2B for leg 2, we will include all 4 combinations.
C        (VEC1A, VEC2A), (VEC1A, VEC2B), etc...
C       The MIN(1,N_SPIN_CORR_RUNS) is just here because the first
C        time we add spin correlation we must start from the blank
C        entries in SPIN_CORR_RUNS(0,*)
        DO J=MIN(1,N_SPIN_CORR_RUNS),N_SPIN_CORR_RUNS
          NEW_N_SPIN_CORR_RUNS = NEW_N_SPIN_CORR_RUNS + 1
          DO N=1,NEXTERNAL
            IF (N.EQ.LEG_INDEX) THEN
C             If the leg is the one selected, enforce the vectors
C              specified by the user
              NEW_SPIN_CORR_RUNS(NEW_N_SPIN_CORR_RUNS,N) = I
            ELSE
C             Otherwise, just copy the ones of the previous runs.
              NEW_SPIN_CORR_RUNS(NEW_N_SPIN_CORR_RUNS,N) =
     $          SPIN_CORR_RUNS(J,N)
            ENDIF
          ENDDO
        ENDDO
      ENDDO

C     That's it, the new runs featuring the combination of previously
C      defined spin correlation vectors with the new ones can be set
C      to SPIN_CORR_RUNS
      N_SPIN_CORR_RUNS = NEW_N_SPIN_CORR_RUNS
      DO I=0, N_SPIN_CORR_RUNS
        DO J=1, NEXTERNAL
          SPIN_CORR_RUNS(I,J) = NEW_SPIN_CORR_RUNS(I,J)
        ENDDO
      ENDDO

      END SUBROUTINE SET_SPIN_CORRELATION_VECTORS

      SUBROUTINE RESET_SPIN_CORRELATION_VECTORS()
      IMPLICIT NONE
C     Resets the spin correlation vectors definition

C     
C     CONSTANTS AND GLOBALS
C     

      INTEGER    NEXTERNAL
      PARAMETER (NEXTERNAL=5)
      INCLUDE 'spin_correlations.inc'

C     
C     LOCAL VARIABLES
C     

      INTEGER I,J,N

C     ----------
C     BEGIN CODE
C     ----------

      DO N=1,NEXTERNAL
        N_SPIN_CORR_VECTORS(N) = 0
        DO I=1,MAX_N_SPIN_CORR_VECTORS
          DO J=1,4
            SPIN_CORR_VECTORS(N,I,J) = 0.0D0
          ENDDO
        ENDDO
      ENDDO

      N_SPIN_CORR_RUNS = 0
      DO I=1,MAX_SPIN_CORR_RUNS
        DO J=1,NEXTERNAL
          SPIN_CORR_RUNS(I,J) = -1000
        ENDDO
      ENDDO

      END SUBROUTINE RESET_SPIN_CORRELATION_VECTORS

      SUBROUTINE GET_MAX_N_SPIN_CORR_VECTORS(MAX_N_SC_VECTORS)
      IMPLICIT NONE
      INTEGER    NEXTERNAL
      PARAMETER (NEXTERNAL=5)
      INCLUDE 'spin_correlations.inc'
      INTEGER MAX_N_SC_VECTORS
CF2PY INTENT(OUT) :: MAX_N_SC_VECTORS
      MAX_N_SC_VECTORS = MAX_N_SPIN_CORR_VECTORS
      END SUBROUTINE GET_MAX_N_SPIN_CORR_VECTORS

      SUBROUTINE GET_MAX_N_SPIN_CORR_LEGS(MAX_N_SC_LEGS)
      IMPLICIT NONE
      INTEGER    NEXTERNAL
      PARAMETER (NEXTERNAL=5)
      INCLUDE 'spin_correlations.inc'
      INTEGER MAX_N_SC_LEGS
CF2PY INTENT(OUT) :: MAX_N_SC_LEGS
      MAX_N_SC_LEGS = MAX_LEGS_WITH_SPIN_CORR
      END SUBROUTINE GET_MAX_N_SPIN_CORR_LEGS

      SUBROUTINE GET_COLOR_CONNECTION_MAX_ORDER(MAX_ORDER)
      IMPLICIT NONE
      INTEGER CC_MAX_ORDER
      PARAMETER (CC_MAX_ORDER=1)
      INTEGER MAX_ORDER
CF2PY INTENT(OUT) :: MAX_ORDER
      MAX_ORDER = CC_MAX_ORDER
      END SUBROUTINE GET_COLOR_CONNECTION_MAX_ORDER

C     Now routines to map the specification of the color connections
C      at each order to a 
C     unique index.
C     
C     NOTE:
C     -----
C     
C     Given the list of k triplets (i,j,k) at N^kLO, returns the index
C      of corresponding color connection
C     See documentation of the function 'generate_all_color_connections'
C     //'' in the file madgraph/core/color_amp.py for the meaning of
C      these triplets.
C     To be more concise the mapping here will be saved with a doublet
C      only, where the differentiation between the g > q q~ and g > g
C      g splitting is not done like this:
C     g > g g  --> (-1,-2,-1)
C     vs
C     g > q q~ --> (-1,-1,-2)
C     but instead is represented by the following two doublets instead:
C     g > g g  --> (-1,-2)
C     vs
C     g > q q~ --> (-1,+2)
C     so the information about inforcing a 'q q~' splitting is carried
C      by the sign of the second entry which would otherwise always be
C      negative.
C     For all other splittings (q > q g and q~ > q~ g), the last entry
C      is always the same as the first, so there is no loss of
C      information.
C     
C     Definition of the color connection to index subroutines starts
C      now
C     -----------------------------------------------------------------
C     -
C     
C     =========================================================
C     Mapping of NLO color connections to a unique index
C     =========================================================

      SUBROUTINE GET_N_COLOR_CONNECTIONS_NLO(N_CC)
      IMPLICIT NONE
      INTEGER N_CC_FOR_THAT_ORDER
      PARAMETER (N_CC_FOR_THAT_ORDER=0)
      INTEGER N_CC
CF2PY INTENT(OUT) :: N_CC
      N_CC = N_CC_FOR_THAT_ORDER
      END SUBROUTINE GET_N_COLOR_CONNECTIONS_NLO

      SUBROUTINE APPLY_COLOR_CONNECTION_DEFINITIONS_NLO()
C     This routine initialise the mapping of the color connections for
C      order NLO

      INTEGER    PERT_ORDER
      PARAMETER (PERT_ORDER=1)
      INTEGER    NEXTERNAL
      PARAMETER (NEXTERNAL=5)
      INTEGER    N_CC_DEFINITION_ENTRIES
      PARAMETER (N_CC_DEFINITION_ENTRIES=NEXTERNAL*PERT_ORDER)

      INTEGER COLOR_CONNECTIONS(NEXTERNAL,-PERT_ORDER:-1)
      LOGICAL COLOR_CONNECTION_INITIALIZED
C     If the color connection doesn't exist, the index returned will
C      be zero
      DATA COLOR_CONNECTIONS/N_CC_DEFINITION_ENTRIES*0/
      DATA COLOR_CONNECTION_INITIALIZED/.FALSE./
      COMMON/COLOR_CONNECTION_DEFINITIONS_NLO/COLOR_CONNECTIONS,
     $  COLOR_CONNECTION_INITIALIZED



      END SUBROUTINE APPLY_COLOR_CONNECTION_DEFINITIONS_NLO

      SUBROUTINE COLOR_CONNECTION_TO_INDEX_NLO(SPECIFIER_A, INDEX_OUT)
      IMPLICIT NONE
C     
C     CONSTANTS
C     
      INTEGER    PERT_ORDER
      PARAMETER (PERT_ORDER=1)
      INTEGER    CC_SPECIFIER_DIMENSION
      PARAMETER (CC_SPECIFIER_DIMENSION=2*PERT_ORDER)
      INTEGER    NEXTERNAL
      PARAMETER (NEXTERNAL=5)
C     
C     ARGUMENTS 
C     
      INTEGER SPECIFIER_A(3)
CF2PY INTENT(IN) :: SPECIFIER_A

      INTEGER INDEX_OUT
CF2PY INTENT(OUT) :: INDEX_OUT

C     
C     LOCAL VARIABLES
C     
      INTEGER I, J
      LOGICAL MATCHED
      INTEGER CC_SPECIFIER(CC_SPECIFIER_DIMENSION)
C     
C     GLOBAL VARIABLES
C     
      INTEGER COLOR_CONNECTIONS(NEXTERNAL,-PERT_ORDER:-1)
      LOGICAL COLOR_CONNECTION_INITIALIZED
      COMMON/COLOR_CONNECTION_DEFINITIONS_NLO/COLOR_CONNECTIONS,
     $  COLOR_CONNECTION_INITIALIZED

C     ----------
C     BEGIN CODE
C     ----------

      IF (.NOT.COLOR_CONNECTION_INITIALIZED) THEN
        COLOR_CONNECTION_INITIALIZED = .TRUE.
        CALL APPLY_COLOR_CONNECTION_DEFINITIONS_NLO()
      ENDIF

C     Set the cc_specifier
      CC_SPECIFIER(1)=SPECIFIER_A(1)
      CC_SPECIFIER(2)=SPECIFIER_A(2)

C     And return it now

      INDEX_OUT = COLOR_CONNECTIONS(CC_SPECIFIER(1),CC_SPECIFIER(2))

      END SUBROUTINE COLOR_CONNECTION_TO_INDEX_NLO

      SUBROUTINE INDEX_TO_COLOR_CONNECTION_NLO(INDEX_IN,SPECIFIER_A)
      IMPLICIT NONE
C     
C     CONSTANTS
C     
      INTEGER    PERT_ORDER
      PARAMETER (PERT_ORDER=1)
      INTEGER NCOLORCONNECTIONS_NLO
      PARAMETER (NCOLORCONNECTIONS_NLO=0)
      INTEGER INDEX_NLO_OFFSET
      PARAMETER (INDEX_NLO_OFFSET=0)

C     
C     ARGUMENTS 
C     
      INTEGER SPECIFIER_A(3)
CF2PY INTENT(OUT) :: SPECIFIER_A

      INTEGER INDEX_IN
CF2PY INTENT(IN) :: INDEX_IN

C     
C     LOCAL VARIABLES
C     
      INTEGER I, J, K
C     
C     GLOBAL VARIABLES
C     
      INTEGER CC_INDEX_TO_DEFINITION_NLO(NCOLORCONNECTIONS_NLO
     $ ,PERT_ORDER,3)

      COMMON/CC_INDEX_TO_DEFINITION_NLO/CC_INDEX_TO_DEFINITION_NLO

C     ----------
C     BEGIN CODE
C     ----------

C     Return the color connection for this index
      SPECIFIER_A(1)=CC_INDEX_TO_DEFINITION_NLO(INDEX_IN
     $ -INDEX_NLO_OFFSET,1,1)
      SPECIFIER_A(2)=CC_INDEX_TO_DEFINITION_NLO(INDEX_IN
     $ -INDEX_NLO_OFFSET,1,2)
      SPECIFIER_A(3)=CC_INDEX_TO_DEFINITION_NLO(INDEX_IN
     $ -INDEX_NLO_OFFSET,1,3)

      END SUBROUTINE INDEX_TO_COLOR_CONNECTION_NLO

      FUNCTION GET_COLOR_CONNECTION_INDEX_NLO(SPECIFIER_A)
      IMPLICIT NONE
C     
C     ARGUMENTS 
C     
      INTEGER SPECIFIER_A(3)

      INTEGER GET_COLOR_CONNECTION_INDEX_NLO
C     
C     LOCAL VARIABLES
C     
      INTEGER CC_INDEX

C     ----------
C     BEGIN CODE
C     ----------

      CALL COLOR_CONNECTION_TO_INDEX_NLO(SPECIFIER_A, CC_INDEX)
      GET_COLOR_CONNECTION_INDEX_NLO = CC_INDEX

      END FUNCTION GET_COLOR_CONNECTION_INDEX_NLO



C     Set of functions to handle the array indices of the split orders


      INTEGER FUNCTION SQSOINDEX(ORDERINDEXA, ORDERINDEXB)
C     
C     This functions plays the role of the interference matrix. It can
C      be hardcoded or 
C     made more elegant using hashtables if its execution speed ever
C      becomes a relevant
C     factor. From two split order indices, it return the
C      corresponding index in the squared 
C     order canonical ordering.
C     
C     CONSTANTS
C     

      INTEGER    NSO, NSQUAREDSO, NAMPSO
      PARAMETER (NSO=2, NSQUAREDSO=5, NAMPSO=3)
C     
C     ARGUMENTS
C     
      INTEGER ORDERINDEXA, ORDERINDEXB
C     
C     LOCAL VARIABLES
C     
      INTEGER I, SQORDERS(NSO)
      INTEGER AMPSPLITORDERS(NAMPSO,NSO)
      DATA (AMPSPLITORDERS(  1,I),I=  1,  2) /    2,    1/
      DATA (AMPSPLITORDERS(  2,I),I=  1,  2) /    1,    2/
      DATA (AMPSPLITORDERS(  3,I),I=  1,  2) /    0,    3/
      COMMON/AMPSPLITORDERS/AMPSPLITORDERS
C     
C     FUNCTION
C     
      INTEGER SOINDEX_FOR_SQUARED_ORDERS
C     
C     BEGIN CODE
C     
      DO I=1,NSO
        SQORDERS(I)=AMPSPLITORDERS(ORDERINDEXA,I)+AMPSPLITORDERS
     $   (ORDERINDEXB,I)
      ENDDO
      SQSOINDEX=SOINDEX_FOR_SQUARED_ORDERS(SQORDERS)
      END

      INTEGER FUNCTION SOINDEX_FOR_SQUARED_ORDERS(ORDERS)
C     
C     This functions returns the integer index identifying the squared
C      split orders list passed in argument which corresponds to the
C      values of the following list of couplings (and in this order).
C     ['QCD', 'QED']
C     
C     CONSTANTS
C     
      INTEGER    NSO, NSQSO, NAMPSO
      PARAMETER (NSO=2, NSQSO=5, NAMPSO=3)
C     
C     ARGUMENTS
C     
      INTEGER ORDERS(NSO)
C     
C     LOCAL VARIABLES
C     
      INTEGER I,J
      INTEGER SQSPLITORDERS(NSQSO,NSO)
      DATA (SQSPLITORDERS(  1,I),I=  1,  2) /    4,    2/
      DATA (SQSPLITORDERS(  2,I),I=  1,  2) /    3,    3/
      DATA (SQSPLITORDERS(  3,I),I=  1,  2) /    2,    4/
      DATA (SQSPLITORDERS(  4,I),I=  1,  2) /    1,    5/
      DATA (SQSPLITORDERS(  5,I),I=  1,  2) /    0,    6/
      COMMON/ALL_SQSPLITORDERS/SQSPLITORDERS
C     
C     BEGIN CODE
C     
      DO I=1,NSQSO
        DO J=1,NSO
          IF (ORDERS(J).NE.SQSPLITORDERS(I,J)) GOTO 1009
        ENDDO
        SOINDEX_FOR_SQUARED_ORDERS = I
        RETURN
 1009   CONTINUE
      ENDDO

      WRITE(*,*) 'ERROR:: Stopping in function'
      WRITE(*,*) 'SOINDEX_FOR_SQUARED_ORDERS'
      WRITE(*,*) 'Could not find squared orders ',(ORDERS(I),I=1,NSO)
      STOP

      END

      SUBROUTINE GET_NSQSO_BORN(NSQSO)
C     
C     Simple subroutine returning the number of squared split order
C     contributions returned when calling smatrix_split_orders 
C     

      INTEGER    NSQUAREDSO
      PARAMETER  (NSQUAREDSO=5)

      INTEGER NSQSO
CF2PY INTENT(OUT) :: NSQSO

      NSQSO=NSQUAREDSO

      END

C     This is the inverse subroutine of SOINDEX_FOR_SQUARED_ORDERS.
C      Not directly useful, but provided nonetheless.
      SUBROUTINE GET_SQUARED_ORDERS_FOR_SOINDEX(SOINDEX,ORDERS)
C     
C     This functions returns the orders identified by the squared
C      split order index in argument. Order values correspond to
C      following list of couplings (and in this order):
C     ['QCD', 'QED']
C     
C     CONSTANTS
C     
      INTEGER    NSO, NSQSO
      PARAMETER (NSO=2, NSQSO=5)
C     
C     ARGUMENTS
C     
      INTEGER SOINDEX, ORDERS(NSO)
CF2PY INTENT(IN) :: SOINDEX
CF2PY INTENT(OUT) :: ORDERS
C     
C     LOCAL VARIABLES
C     
      INTEGER I
      INTEGER SQSPLITORDERS(NSQSO,NSO)
      COMMON/ALL_SQSPLITORDERS/SQSPLITORDERS
C     
C     BEGIN CODE
C     
      IF (SOINDEX.GT.0.AND.SOINDEX.LE.NSQSO) THEN
        DO I=1,NSO
          ORDERS(I) =  SQSPLITORDERS(SOINDEX,I)
        ENDDO
        RETURN
      ENDIF

      WRITE(*,*) 'ERROR:: Stopping function GET_SQUARED_ORDERS_FOR_SOIN'
     $ //'DEX'
      WRITE(*,*) 'Could not find squared orders index ',SOINDEX
      STOP

      END SUBROUTINE

C     This is the inverse subroutine of getting amplitude SO orders.
C      Not directly useful, but provided nonetheless.
      SUBROUTINE GET_ORDERS_FOR_AMPSOINDEX(SOINDEX,ORDERS)
C     
C     This functions returns the orders identified by the split order
C      index in argument. Order values correspond to following list of
C      couplings (and in this order):
C     ['QCD', 'QED']
C     
C     CONSTANTS
C     
      INTEGER    NSO, NAMPSO
      PARAMETER (NSO=2, NAMPSO=3)
C     
C     ARGUMENTS
C     
      INTEGER SOINDEX, ORDERS(NSO)
C     
C     LOCAL VARIABLES
C     
      INTEGER I
      INTEGER AMPSPLITORDERS(NAMPSO,NSO)
      COMMON/AMPSPLITORDERS/AMPSPLITORDERS
C     
C     BEGIN CODE
C     
      IF (SOINDEX.GT.0.AND.SOINDEX.LE.NAMPSO) THEN
        DO I=1,NSO
          ORDERS(I) =  AMPSPLITORDERS(SOINDEX,I)
        ENDDO
        RETURN
      ENDIF

      WRITE(*,*) 'ERROR:: Stopping function GET_ORDERS_FOR_AMPSOINDEX'
      WRITE(*,*) 'Could not find amplitude split orders index ',SOINDEX
      STOP

      END SUBROUTINE

C     This function is not directly useful, but included for
C      completeness
      INTEGER FUNCTION SOINDEX_FOR_AMPORDERS(ORDERS)
C     
C     This functions returns the integer index identifying the
C      amplitude split orders passed in argument which correspond to
C      the values of the following list of couplings (and in this
C      order):
C     ['QCD', 'QED']
C     
C     CONSTANTS
C     
      INTEGER    NSO, NAMPSO
      PARAMETER (NSO=2, NAMPSO=3)
C     
C     ARGUMENTS
C     
      INTEGER ORDERS(NSO)
C     
C     LOCAL VARIABLES
C     
      INTEGER I,J
      INTEGER AMPSPLITORDERS(NAMPSO,NSO)
      COMMON/AMPSPLITORDERS/AMPSPLITORDERS
C     
C     BEGIN CODE
C     
      DO I=1,NAMPSO
        DO J=1,NSO
          IF (ORDERS(J).NE.AMPSPLITORDERS(I,J)) GOTO 1009
        ENDDO
        SOINDEX_FOR_AMPORDERS = I
        RETURN
 1009   CONTINUE
      ENDDO

      WRITE(*,*) 'ERROR:: Stopping function SOINDEX_FOR_AMPORDERS'
      WRITE(*,*) 'Could not find squared orders ',(ORDERS(I),I=1,NSO)
      STOP

      END

C     --------
C     Now defining F2PY hooks.
C     --------

      SUBROUTINE GET_SPLIT_ORDER_NAMES(SONAMES)
      IMPLICIT NONE
C     
C     CONSTANTS
C     
      INTEGER    NSO
      PARAMETER (NSO=2)
C     ARGUMENTS
C     
      CHARACTER*100 SONAMES(NSO)
      INTEGER IDX
CF2PY INTENT(OUT) :: SONAMES
C     
C     BEGIN CODE
C     
      SONAMES(1)='QCD'
      SONAMES(2)='QED'

      END


